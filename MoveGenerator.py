import copy
import time

# TODO: There is an issue with the jump algorithms. A pawn may reach the same position in multiple ways by jumping. This
# results in the same move being created and recorded twice. There needs to be a way to keep track of moves that a pawn
# has already discovered. More specifically, record places on the board where the pawn has already discovered a move to.
# So create a board that keeps track of these moves, and when the pawn looks for another jump move, the old positions
# will already be blocked.

def get_board_set(board):
    board_set = set([])
    for i in range(len(board)):
        for j in range(len(board[0])):
            board_set.add((i,j))
    return board_set

# initial 6x6 board
global_board = [[0, 0, 0, 0, 2, 2, 2, 2],
                [0, 0, 0, 0, 0, 2, 2, 2],
                [0, 0, 0, 0, 0, 0, 2, 2],
                [0, 0, 0, 0, 0, 0, 0, 2],
                [1, 0, 0, 0, 0, 0, 0, 0],
                [1, 1, 0, 0, 0, 0, 0, 0],
                [1, 1, 1, 0, 0, 0, 0, 0],
                [1, 1, 1, 1, 0, 0, 0, 0]]

board_tiles = get_board_set(global_board)
columns = len(global_board[0])  # columns (elem index in row)
rows = len(global_board)  # rows
player_name = 1


# generates all moves for one player
# returns a list of boards that can be generated after one legal move
def move_generator():
    """
    Generate all moves for one player
    :return: A list of all boards generated by each legal move
    """
    moves = []
    for y in range(rows):
        for x in range(columns):
            if global_board[y][x] == player_name: # position holds a player 1 pawn
                # generate all moves for that pawn and add them to the list of moves
                moves += gen_pawn_moves(x, y)

    return moves


def gen_pawn_moves(x,y):
    """
    Generate all moves for one pawn
    :param x: The column position of the pawn
    :param y: The row position of the pawn
    :return: A list of boards created by each move
    """
    moves = []
    # find all the single-moves a pawn could take and add them to the list of moves
    moves += gen_single_moves(x,y)
    # find all the jump-moves a pawn could take and add them to the list of moves
    moves += gen_jump_moves(x,y)
    return moves


def gen_single_moves(x,y):
    """
    Generate all single-position moves a pawn could take
    :param x: The column position of the pawn
    :param y: The row position of the pawn
    :return: A list of boards created by each single-move
    """
    moves = []
    # The positions to consider:
    consider = gen_next_positions(x, y)
    for position in consider:
        column, row = position
        # if there is no pawn in that position, the current pawn can move there
        if global_board[row][column] == 0:
            # the new board this move would create
            new_board = copy.deepcopy(global_board)
            new_board[y][x] = 0
            new_board[row][column] = player_name
            # add the new board to the list of moves
            moves.append(new_board)
    return moves


def gen_jump_moves(x, y, board=None, path=None):
    """
    Generate all jump-moves a pawn could take, without making duplicate moves - where the pawn can make the same move,
    but by jumping a different path.
    
    Because jump moves can be chained, it must find those as well, using RECURSION to keep jumping until there are no 
    more positions to jump to.
    
    The algorithm works by looking at one pawn, and checking all the positions around it to see if there is a pawn to
    jump. Then it makes the jump, creating the new_board and saving it to the list of moves, and also records this move
    in the path set. This path set is created on the first run of this method, so each pawn has it's own path set. 
    The current move is checked against the path set, blocking the pawn from going to that position again, as it would
    be a waste of time.
    
    :param x: The column position of the pawn
    :param y: The row position of the pawn
    :param board: A board object (2D Array) that represents the current move/board the pawn is making
    :param path: A set of coordinates of places that the pawn has already discovered
    :return: A list of boards created by each move
    """
    # DEBUG ============================================================================================================
    # print("Running jump moves algorithm...\n")
    # ==================================================================================================================

    moves = []  # a list of moves to be returned

    # The positions to consider:
    consider = gen_next_positions(x, y)

    # Look at each position
    for position in consider:
        i,j = position
        # If no boards passed in, we look at the initial board (This is the first jump!)
        if board is None:
            board = copy.deepcopy(global_board)
        if path is None:
            path = {(x,y)}
        # Otherwise, we continue with the boards passed in, which are the boards created from the last jump move!

        # If there is a pawn in that position, we can possibly jump it
        if board[j][i] in [1,2]:
            # check if there is space open to jump, and if the jump takes the pawn off the board
            new_x, new_y = jump(x,y,i,j)        # get the coordinates of where the pawn will land
            z = prune({(new_x,new_y)})          # prune the coordinates away if it is outside the board

            # If there is a place to land (inside the board, not on the path, and on an empty space)
            if len(z) != 0 and len(z & path) == 0 and board[new_y][new_x] == 0:

                # DEBUG ================================================================================================
                # print("Jumping pawn (" + str(x) + "," + str(y) + ") to space (" + str(new_x) + "," + str(new_y) + ")\n")
                # print("Current Board")
                # display_board(board)
                # print()
                # ======================================================================================================

                # Make the new board this move would create
                # ------------------------------------------------------------------------------------------------------
                new_board = copy.deepcopy(board)                # copy the previous board
                new_board[y][x] = 0                             # remove the pawn from its old position
                new_board[new_y][new_x] = player_name           # place it in its new position
                # ------------------------------------------------------------------------------------------------------

                # DEBUG ================================================================================================
                # print("New board created by move:")
                # display_board(new_board)
                # print()
                # ======================================================================================================

                # ------------------------------------------------------------------------------------------------------
                moves.append(new_board)                         # add the new board to the list of moves
                # ------------------------------------------------------------------------------------------------------

                # ------------------------------------------------------------------------------------------------------
                path.add((new_x, new_y))                                 # add the previous position to the path
                # ------------------------------------------------------------------------------------------------------

                # DEBUG ================================================================================================
                # print("Path:")
                # print(path)
                # print()
                # ======================================================================================================

                # Look for another jump!
                moves += gen_jump_moves(new_x, new_y, new_board, path)

    return moves


def jump(x,y,i,j):
    """
    Calculates the new position of a jumping pawn
    Assumes all given coordinates are correct
    :param x: column coordinate of the pawn's current position
    :param y: row coordinate of the pawn's current position
    :param i: column coordinate of the pawn it is jumping
    :param j: row coordinate of the pawn it is jumping
    :return: new coordinate position of the pawn after it jumps
    """
    c = x-i
    k = y-j
    new_x = x-2*c
    new_y = y-2*k
    return new_x, new_y


def gen_next_positions(x, y):
    """
    Generates a set of (x,y) positions that a pawn must consider when moving
    :param x: The column position of the pawn
    :param y: The row position of the pawn
    :return: A set of positions surrounding the pawn
    """
    next_set = {(x - 1, y - 1),
                (x - 1, y    ),
                (x - 1, y + 1),
                (x    , y - 1),
                (x    , y + 1),
                (x + 1, y - 1),
                (x + 1, y    ),
                (x + 1, y + 1)}
    #
    #   [x-1, y-1]   [x-1,   y]   [x-1, y+1]
    #   [x,   y-1]     (x,y)      [x,   y+1]
    #   [x+1, y-1]   [x+1,   y]   [x+1, y+1]
    #
    # TODO: prune the positions that are out of range
    next_set = prune(next_set)
    return next_set


def prune(tiles):
    """
    Prunes away tiles that are out of the board from a set of tiles
    :param tiles: set of tiles (x,y) positions of the board
    :return: A pruned set of tiles that doesn't include out of range tiles
    """
    tiles &= board_tiles

    return tiles


def display_board(board):
    for row in board:
        for column in row:
            print(column, end=' ')
        print()

"""
# board for testing jumps 8x8
jump_board = [[0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,2,0,0],
              [0,0,0,0,0,0,0,0],
              [0,2,0,2,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [2,2,0,2,0,0,0,0],
              [1,2,0,0,0,0,0,0]]

jump_board_tiles = get_board_set(jump_board)
"""


def __main__():

    print('INITIAL BOARD:')
    display_board(global_board)
    print()

    start = time.time()
    moves = move_generator()
    end = time.time()
    t = end-start

    i = 1
    for move in moves:
        print("(" + str(i) + ")")
        display_board(move)
        print()
        i += 1

    print('INITIAL BOARD:')
    display_board(global_board)
    print()

    print("Found " + str(i) + " moves in " + str(t) + " seconds")


if __name__ == '__main__':
    __main__()

